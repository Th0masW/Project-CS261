{"version":3,"sources":["../../lib/merlinparks/index.js"],"names":["Park","require","Moment","uuid","unzip","s_apiKey","Symbol","s_apiBase","s_appVersion","s_appBuild","s_deviceID","s_dataVersion","s_fallbackData","s_deviceTokenCacheTime","s_userIDCacheTime","s_dataCacheTime","MerlinPark","options","name","useragent","api_key","Error","initial_data_version","app_build","app_version","device_id","api_base","device_token_cachetime","user_id_cachetime","data_cachetime","fallback_data","GetParkData","then","rideNames","MakeAPICall","url","APIBase","data","i","ride","entities","Item","records","rideObject","GetRideObject","id","_id","Log","WaitTime","IsOpen","QueueTime","Promise","resolve","Cache","Wrap","GenerateUserID","user_id","HTTP","method","user_identifier","device_identifier","headers","token","reject","newUserID","FetchParkData","DataVersion","rideData","item","Name","version","returnFullResponse","response","statusCode","fromBuffer","body","lazyEntries","err","zip","manifestData","recordsData","GetNextEntry","catch","readEntry","on","file","fileName","ReadZipFile","RegisterDevice","startDate","endDate","isOpen","openingHours","validRange","range","startOf","endOf","type","result","exec","replace","openingTime","closingTime","Schedule","SetRange","module","exports","openReadStream","readStream","chunk","JSON","parse","e"],"mappings":"AAAA;;AAEA;;;;;;;;;;AACA,IAAMA,OAAOC,QAAQ,SAAR,CAAb;AACA,IAAMC,SAASD,QAAQ,iBAAR,CAAf;;AAEA;AACA,IAAME,OAAOF,QAAQ,SAAR,CAAb;AACA;AACA,IAAMG,QAAQH,QAAQ,OAAR,CAAd;;AAEA,IAAMI,WAAWC,QAAjB;AACA,IAAMC,YAAYD,QAAlB;AACA,IAAME,eAAeF,QAArB;AACA,IAAMG,aAAaH,QAAnB;AACA,IAAMI,aAAaJ,QAAnB;AACA,IAAMK,gBAAgBL,QAAtB;AACA,IAAMM,iBAAiBN,QAAvB;;AAEA,IAAMO,yBAAyBP,QAA/B;AACA,IAAMQ,oBAAoBR,QAA1B;AACA,IAAMS,kBAAkBT,QAAxB;;AAEA;;;;;;IAKMU,U;;;AACF;;;;;;;;;;;;;;;AAeA,0BAA0B;AAAA,YAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACtBA,gBAAQC,IAAR,GAAeD,QAAQC,IAAR,IAAgB,aAA/B;;AAEA;AACA;AACAD,gBAAQE,SAAR,GAAoBF,QAAQE,SAAR,IAAqB,cAAzC;;AAEA;;AAGA;AAVsB,4HAQhBF,OARgB;;AAWtB,YAAI,CAACA,QAAQG,OAAb,EAAsB,MAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACtB,cAAKhB,QAAL,IAAiBY,QAAQG,OAAzB;AACA,YAAI,CAACH,QAAQK,oBAAb,EAAmC,MAAM,IAAID,KAAJ,CAAU,kEAAV,CAAN;AACnC,cAAKV,aAAL,IAAsBM,QAAQK,oBAA9B;;AAEA;AACA,cAAKb,UAAL,IAAmBQ,QAAQM,SAAR,IAAqB,GAAxC;AACA,cAAKf,YAAL,IAAqBS,QAAQO,WAAR,IAAuB,OAA5C;AACA,cAAKd,UAAL,IAAmBO,QAAQQ,SAAR,IAAqB,KAAxC;;AAEA;AACA,cAAKlB,SAAL,IAAkBU,QAAQS,QAAR,IAAoB,gCAAtC;;AAEA;AACA,cAAKb,sBAAL,IAA+BI,QAAQU,sBAAR,IAAkC,QAAjE,CAzBsB,CAyBqD;AAC3E,cAAKb,iBAAL,IAA0BG,QAAQW,iBAAR,IAA6B,QAAvD,CA1BsB,CA0B2C;AACjE,cAAKb,eAAL,IAAwBE,QAAQY,cAAR,IAA0B,QAAlD,CA3BsB,CA2BsC;;AAE5D;AACA,cAAKjB,cAAL,IAAuBK,QAAQa,aAA/B;AA9BsB;AA+BzB;;AAED;;;;;;;yCAOiB;AAAA;;AACb;AACA,mBAAO,KAAKC,WAAL,GAAmBC,IAAnB,CAAwB,UAACC,SAAD,EAAe;AAC1C;AACA,uBAAO,OAAKC,WAAL,CAAiB;AACpBC,yBAAQ,OAAKC,OAAb;AADoB,iBAAjB,EAEJJ,IAFI,CAEC,UAACK,IAAD,EAAU;AACd,yBAAK,IAAIC,IAAI,CAAR,EAAWC,IAAhB,EAAsBA,OAAOF,KAAKG,QAAL,CAAcC,IAAd,CAAmBC,OAAnB,CAA2BJ,GAA3B,CAA7B,GAA+D;AAC3D;AACA,4BAAIK,aAAa,OAAKC,aAAL,CAAmB;AAChCC,gCAAIN,KAAKO,GADuB;AAEhC5B,kCAAMe,UAAUM,KAAKO,GAAf;AAF0B,yBAAnB,CAAjB;;AAKA,4BAAI,CAACH,UAAL,EAAiB;AACb,mCAAKI,GAAL,kCAAwCR,KAAKM,EAA7C;AACH,yBAFD,MAEO;AACH;AACAF,uCAAWK,QAAX,GAAsBT,KAAKU,MAAL,GAAeV,KAAKW,SAAL,GAAiB,EAAhC,GAAsC,CAAC,CAA7D;AACH;AACJ;;AAED,2BAAOC,QAAQC,OAAR,EAAP;AACH,iBAnBM,CAAP;AAoBH,aAtBM,CAAP;AAuBH;;AAED;;;;;;yCAGiB;AAAA;;AACb;AACA,mBAAO,KAAKC,KAAL,CAAWC,IAAX,CAAgB,cAAhB,EAAgC,YAAM;AACzC;AACA,uBAAO,OAAKC,cAAL,GAAsBvB,IAAtB,CAA2B,UAACwB,OAAD,EAAa;AAC3C;AACA,2BAAO,OAAKC,IAAL,CAAU;AACbtB,6BAAQ,OAAK5B,SAAL,CAAR,iBADa;AAEbmD,gCAAQ,MAFK;AAGbrB,8BAAM;AACFsB,6CAAiBH,OADf;AAEFI,+CAAmB,OAAKlD,UAAL,CAFjB;AAGFc,yCAAa,OAAKhB,YAAL,CAHX;AAIFe,uCAAW,OAAKd,UAAL;AAJT,yBAHO;AASboD,iCAAS;AACL,gDAAoB,SADf;AAEL,wDAA4B,OAFvB;AAGL,mDAAuB,OAAKrD,YAAL,CAHlB;AAIL,iDAAqB,OAAKC,UAAL,CAJhB;AAKL,2EAA4C,OAAKJ,QAAL,CAA5C;AALK;AATI,qBAAV,EAgBJ2B,IAhBI,CAgBC,UAACK,IAAD,EAAU;AACd,4BAAIA,QAAQA,KAAKyB,KAAjB,EAAwB;AACpB,mCAAOX,QAAQC,OAAR,CAAgBf,KAAKyB,KAArB,CAAP;AACH;;AAED,+BAAOX,QAAQY,MAAR,CAAe,kBAAf,CAAP;AACH,qBAtBM,CAAP;AAuBH,iBAzBM,CAAP;AA0BH,aA5BM,EA4BJ,KAAKlD,sBAAL,CA5BI,CAAP;AA6BH;;AAED;;;;;;yCAGiB;AAAA;;AACb,mBAAO,KAAKwC,KAAL,CAAWC,IAAX,CAAgB,SAAhB,EAA2B,YAAM;AACpC;AACA,oBAAMU,YAAY7D,MAAlB;;AAEA,uBAAK4C,GAAL,2BAAiCiB,SAAjC;;AAEA,uBAAOb,QAAQC,OAAR,CAAgBY,SAAhB,CAAP;AACH,aAPM,EAOJ,KAAKlD,iBAAL,CAPI,CAAP;AAQH;;AAED;;;;;;sCAGc;AAAA;;AACV,mBAAO,KAAKuC,KAAL,CAAWC,IAAX,CAAgB,MAAhB,EAAwB,YAAM;AACjC;AACA,uBAAO,OAAKW,aAAL,CAAmB,OAAKC,WAAxB,EAAqClC,IAArC,CAA0C,UAACK,IAAD,EAAU;AACvD,wBAAI8B,WAAW,EAAf;AACA,yBAAK,IAAI7B,IAAI,CAAR,EAAW8B,IAAhB,EAAsBA,OAAO/B,KAAKI,IAAL,CAAUH,GAAV,CAA7B,GAA8C;AAC1C6B,iCAASC,KAAKtB,GAAd,IAAqBsB,KAAKC,IAA1B;AACH;AACD,2BAAOlB,QAAQC,OAAR,CAAgBe,QAAhB,CAAP;AACH,iBANM,CAAP;AAOH,aATM,EASJ,KAAKpD,eAAL,CATI,CAAP;AAUH;;AAED;;;;;;;;AAOA;;;;sCAIcuD,O,EAAS;AAAA;;AACnB;AACA;;AAEA;AACA,iBAAK3D,aAAL,IAAsB2D,OAAtB;;AAEA;AACA,mBAAO,KAAKpC,WAAL,CAAiB;AACpBC,qBAAQ,KAAK5B,SAAL,CAAR,SADoB;AAEpB8B,sBAAM;AACFiC,6BAASA;AADP,iBAFc;AAKpB;AACAC,oCAAoB;AANA,aAAjB,EAOJvC,IAPI,CAOC,UAACwC,QAAD,EAAc;AAClB,oBAAIA,SAASC,UAAT,KAAwB,GAAxB,IAA+BD,SAASC,UAAT,KAAwB,GAA3D,EAAgE;AAC5D;AACA,2BAAK1B,GAAL,qBAA2ByB,SAASC,UAApC,gCAAyEH,OAAzE;AACA,2BAAOnB,QAAQY,MAAR,EAAP;AACH,iBAJD,MAIO;AACH,2BAAKhB,GAAL,gCAAsCuB,OAAtC;;AAEA,2BAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUW,MAAV,EAAqB;AACpC;AACA3D,8BAAMsE,UAAN,CAAiBF,SAASG,IAA1B,EAAgC;AAC5BC,yCAAa;AADe,yBAAhC,EAEG,UAACC,GAAD,EAAMC,GAAN,EAAc;AACb,gCAAIC,YAAJ;AACA,gCAAIC,WAAJ;;AAEA,mCAAKjC,GAAL,CAAS,kBAAT;AACA,gCAAI8B,GAAJ,EAAS;AACL,uCAAOd,OAAOc,GAAP,CAAP;AACH;;AAED,gCAAMI,eAAe,SAAfA,YAAe,GAAM;AACvB,oCAAIF,gBAAgBC,WAApB,EAAiC;AAC7B;;AAEA;AACA,wCAAID,aAAaT,OAAjB,EAA0B;AACtB,+CAAKL,aAAL,CAAmBc,aAAaT,OAAhC,EAAyCY,KAAzC,CAA+C,YAAM;AACjD;AACA,mDAAO9B,QAAQ4B,WAAR,CAAP;AACH,yCAHD;AAIH,qCALD,MAKO;AACH,+CAAO5B,QAAQ4B,WAAR,CAAP;AACH;AACJ,iCAZD,MAYO;AACH;AACAF,wCAAIK,SAAJ;AACH;AACJ,6BAjBD;;AAmBAL,gCAAIM,EAAJ,CAAO,OAAP,EAAgB,UAACC,IAAD,EAAU;AACtB,uCAAKtC,GAAL,mBAAyBsC,KAAKC,QAA9B;;AAEA;AACA,oCAAID,KAAKC,QAAL,IAAiB,eAArB,EAAsC;AAClCC,gDAAYT,GAAZ,EAAiBO,IAAjB,EAAuBrD,IAAvB,CAA4B,UAACK,IAAD,EAAU;AAClC0C,uDAAe1C,IAAf;;AAEA4C;AACH,qCAJD;AAKH,iCAND,MAMO,IAAII,KAAKC,QAAL,IAAiB,cAArB,EAAqC;AACxCC,gDAAYT,GAAZ,EAAiBO,IAAjB,EAAuBrD,IAAvB,CAA4B,UAACK,IAAD,EAAU;AAClC2C,sDAAc3C,IAAd;;AAEA4C;AACH,qCAJD;AAKH,iCANM,MAMA;AACHA;AACH;AACJ,6BAnBD;;AAqBA;AACAH,gCAAIK,SAAJ;AACH,yBArDD;AAsDH,qBAxDM,CAAP;AAyDH;AACJ,aAzEM,EAyEJD,KAzEI,CAyEE,eAAO;AACZ,oBAAI,OAAKtE,cAAL,CAAJ,EAA0B;AACtB,2BAAO,OAAKA,cAAL,CAAP;AACH;AACD,sBAAMiE,GAAN;AACH,aA9EM,CAAP;AA+EH;;AAED;;;;;;;;AAOA;;;;;;;sCAUG;AAAA;;AAAA,gBAHS5D,OAGT,uEAHmB;AAClByC,wBAAQ,KADU;AAElBrB,sBAAM;AAFY,aAGnB;;AACC;AACA,mBAAO,KAAKmD,cAAL,GAAsBxD,IAAtB,CAA2B,UAAC8B,KAAD,EAAW;AACzC;AACA,oBAAI,CAAC7C,QAAQ4C,OAAb,EAAsB;AAClB5C,4BAAQ4C,OAAR,GAAkB,EAAlB;AACH;AACD5C,wBAAQ4C,OAAR,CAAgB,kBAAhB,IAAsC,SAAtC;AACA5C,wBAAQ4C,OAAR,CAAgB,0BAAhB,IAA8C,OAA9C;AACA5C,wBAAQ4C,OAAR,CAAgB,qBAAhB,IAAyC,OAAKrD,YAAL,CAAzC;AACAS,wBAAQ4C,OAAR,CAAgB,mBAAhB,IAAuC,OAAKpD,UAAL,CAAvC;AACAQ,wBAAQ4C,OAAR,CAAgB,eAAhB,kCAA8D,OAAKxD,QAAL,CAA9D,iCAAsGyD,KAAtG;;AAEA;AACA,uBAAO,OAAKL,IAAL,CAAUxC,OAAV,CAAP;AACH,aAbM,CAAP;AAcH;;;uCAEcwE,S,EAAWC,O,EAASC,M,EAAQC,Y,EAAc;AACrD,gBAAI,CAACH,SAAD,IAAc,CAACC,OAAnB,EAA4B;AACxB,qBAAK3C,GAAL,kCAAwC0C,SAAxC,YAAwDC,OAAxD;AACA;AACH;;AAED,gBAAIG,aAAa,IAAjB;AACA,gBAAIC,QAAQ;AACRL,2BAAWvF,OAAOuF,SAAP,EAAkB,qBAAlB,EAAyCM,OAAzC,CAAiD,KAAjD,CADH;AAERL,yBAASxF,OAAOwF,OAAP,EAAgB,qBAAhB,EAAuCM,KAAvC,CAA6C,KAA7C,CAFD;AAGRC,sBAAMN,SAAS,WAAT,GAAuB;AAHrB,aAAZ;;AAMA,iBAAK5C,GAAL,iBAAuB+C,MAAML,SAA7B,YAA6CK,MAAMJ,OAAnD;;AAEA,gBAAIC,MAAJ,EAAY;AACR,oBAAIO,eAAJ;AACA;AACA,oBAAIA,SAAS,8CAA8CC,IAA9C,CAAmDP,aAAaQ,OAAb,CAAqB,KAArB,EAA4B,GAA5B,CAAnD,CAAb,EAAmG;AAC/FN,0BAAMO,WAAN,GAAoBnG,OAAOgG,OAAO,CAAP,EAAUE,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAP,EAAoC,QAApC,CAApB;AACAN,0BAAMQ,WAAN,GAAoBpG,OAAOgG,OAAO,CAAP,EAAUE,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAP,EAAoC,QAApC,CAApB;AACH;AACD;AAJA,qBAKK,IAAIF,SAAS,4BAA4BC,IAA5B,CAAiCP,aAAaQ,OAAb,CAAqB,KAArB,EAA4B,GAA5B,CAAjC,CAAb,EAAiF;AAClFN,8BAAMO,WAAN,GAAoBnG,OAAOgG,OAAO,CAAP,IAAY,OAAnB,EAA4B,QAA5B,CAApB;AACAJ,8BAAMQ,WAAN,GAAoBpG,OAAOgG,OAAO,CAAP,IAAY,OAAnB,EAA4B,QAA5B,CAApB;AACH,qBAHI,MAGE;AACHL,qCAAa,KAAb;AACA,6BAAK9C,GAAL,wCAA8C6C,YAA9C;AACH;AACJ;;AAED,gBAAIC,UAAJ,EAAgB;AACZ,qBAAKU,QAAL,CAAcC,QAAd,CAAuBV,KAAvB;AACH;AACJ;;;4BA3Qa;AACV,mBAAO,KAAKvF,SAAL,CAAP;AACH;;;4BAkGiB;AACd,mBAAO,KAAKI,aAAL,CAAP;AACH;;;4BAkGkB;AACf,mBAAO,KAAKC,cAAL,CAAP;AACH;;;;EA9PoBZ,I;;AAkUzB;;;AACAyG,OAAOC,OAAP,GAAiB1F,UAAjB;;AAEA;AACA,SAASuE,WAAT,CAAqBT,GAArB,EAA0BO,IAA1B,EAAgC;AAC5B,WAAO,IAAIlC,OAAJ,CAAY,UAACC,OAAD,EAAUW,MAAV,EAAqB;AACpC,YAAI1B,OAAO,EAAX;AACAyC,YAAI6B,cAAJ,CAAmBtB,IAAnB,EAAyB,UAASR,GAAT,EAAc+B,UAAd,EAA0B;AAC/C,gBAAI/B,GAAJ,EAAS;AACL,uBAAOd,OAAOc,GAAP,CAAP;AACH;;AAED+B,uBAAWxB,EAAX,CAAc,MAAd,EAAsB,UAASyB,KAAT,EAAgB;AAClCxE,wBAAQwE,KAAR;AACH,aAFD,EAEGzB,EAFH,CAEM,KAFN,EAEa,YAAW;AACpB;AACA,oBAAI;AACA/C,2BAAOyE,KAAKC,KAAL,CAAW1E,IAAX,CAAP;AACA,2BAAOe,QAAQf,IAAR,CAAP;AACH,iBAHD,CAGE,OAAO2E,CAAP,EAAU;AACR,2BAAOjD,wCAAsCsB,KAAKC,QAA3C,UAAwD0B,CAAxD,CAAP;AACH;AACJ,aAVD;AAWH,SAhBD;AAiBH,KAnBM,CAAP;AAoBH","file":"index.js","sourcesContent":["\"use strict\";\n\n// include core Park class\nconst Park = require(\"../park\");\nconst Moment = require(\"moment-timezone\");\n\n// uuid generation lib\nconst uuid = require(\"uuid/v4\");\n// zip lib to extract data\nconst unzip = require(\"yauzl\");\n\nconst s_apiKey = Symbol();\nconst s_apiBase = Symbol();\nconst s_appVersion = Symbol();\nconst s_appBuild = Symbol();\nconst s_deviceID = Symbol();\nconst s_dataVersion = Symbol();\nconst s_fallbackData = Symbol();\n\nconst s_deviceTokenCacheTime = Symbol();\nconst s_userIDCacheTime = Symbol();\nconst s_dataCacheTime = Symbol();\n\n/**\n * Implements the Merlin Park API framework. Thorpe Park, Alton Towers, Chessington etc. use this API framework\n * @class\n * @extends Park\n */\nclass MerlinPark extends Park {\n    /**\n     * Create new Merlin Object.\n     * This object should not be called directly, but rather extended for each of the individual Merlin parks\n     * @param {Object} options\n     * @param {String} options.api_key API key to access this park's API\n     * @param {String} [options.api_base] API Base to use when accessing the API\n     * @param {String} [options.app_build] Build version of the app (optional)\n     * @param {String} [options.app_version] App version of the app (optional)\n     * @param {String} [options.device_id] Device identifier for use against the API (optional)\n     * @param {String} [options.initial_data_version] The initial version timestamp to fetch (optional)\n     * @param {Number} [options.device_token_cachetime=86400000] Time to cache device token, in milliseconds (optional)\n     * @param {Number} [options.user_id_cachetime=43200000] Time to cache user ID, in milliseconds (optional)\n     * @param {Number} [options.data_cachetime=43200000] Time to ride data, in milliseconds (optional)\n     * @param {Object} [options.fallback_data=undefined] Fallback data if the ride data cannot be optained (optional)\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Merlin Park\";\n\n        // hard-code UserAgent for these parks\n        //  do this before calling super, so we don't get a randomly generated one\n        options.useragent = options.useragent || \"okhttp/3.2.0\";\n\n        // inherit from base class\n        super(options);\n\n        // custom API options\n        if (!options.api_key) throw new Error(\"Merlin Parks require an API key\");\n        this[s_apiKey] = options.api_key;\n        if (!options.initial_data_version) throw new Error(\"Merlin Parks require an initial data version to fetch ride names\");\n        this[s_dataVersion] = options.initial_data_version;\n\n        // app version options (optionally overriden)\n        this[s_appBuild] = options.app_build || \"5\";\n        this[s_appVersion] = options.app_version || \"1.0.1\";\n        this[s_deviceID] = options.device_id || \"123\";\n\n        // default base API\n        this[s_apiBase] = options.api_base || \"https://api.attractions.io/v1/\";\n\n        // cache times\n        this[s_deviceTokenCacheTime] = options.device_token_cachetime || 86400000; // default: 24 hours\n        this[s_userIDCacheTime] = options.user_id_cachetime || 43200000; // default: 12 hours\n        this[s_dataCacheTime] = options.data_cachetime || 43200000; // default: 12 hours\n\n        // Fallback data\n        this[s_fallbackData] = options.fallback_data;\n    }\n\n    /**\n     * Get the API Base URL\n     */\n    get APIBase() {\n        return this[s_apiBase];\n    }\n\n    FetchWaitTimes() {\n        // first, make sure we have our park data (ride names etc.)\n        return this.GetParkData().then((rideNames) => {\n            // fetch wait times\n            return this.MakeAPICall({\n                url: `${this.APIBase}live-data`\n            }).then((data) => {\n                for (var i = 0, ride; ride = data.entities.Item.records[i++];) {\n                    // apply each wait time data\n                    var rideObject = this.GetRideObject({\n                        id: ride._id,\n                        name: rideNames[ride._id],\n                    });\n\n                    if (!rideObject) {\n                        this.Log(`Failed to find ride with ID ${ride.id}`);\n                    } else {\n                        // update ride wait time (wait times are in seconds in this API!)\n                        rideObject.WaitTime = ride.IsOpen ? (ride.QueueTime / 60) : -1;\n                    }\n                }\n\n                return Promise.resolve();\n            });\n        });\n    }\n\n    /**\n     * Get an API token from cache or through registering a new device\n     */\n    RegisterDevice() {\n        // fetch new device token if we haven't already got one in our cache\n        return this.Cache.Wrap(\"device_token\", () => {\n            // first, get (or generate) a new user ID\n            return this.GenerateUserID().then((user_id) => {\n                // request token for further API requests\n                return this.HTTP({\n                    url: `${this[s_apiBase]}installation`,\n                    method: \"POST\",\n                    data: {\n                        user_identifier: user_id,\n                        device_identifier: this[s_deviceID],\n                        app_version: this[s_appVersion],\n                        app_build: this[s_appBuild]\n                    },\n                    headers: {\n                        \"occasio-platform\": \"Android\",\n                        \"occasio-platform-version\": \"6.0.1\",\n                        \"occasio-app-version\": this[s_appVersion],\n                        \"occasio-app-build\": this[s_appBuild],\n                        \"authorization\": `Attractions-Io api-key \"${this[s_apiKey]}\"`,\n                    }\n                }).then((data) => {\n                    if (data && data.token) {\n                        return Promise.resolve(data.token);\n                    }\n\n                    return Promise.reject(\"No data returned\");\n                });\n            });\n        }, this[s_deviceTokenCacheTime]);\n    }\n\n    /**\n     * Generate (or fetch a cached) user ID\n     */\n    GenerateUserID() {\n        return this.Cache.Wrap(\"user_id\", () => {\n            // generate new UUID if cache hit fails\n            const newUserID = uuid();\n\n            this.Log(`Generated new UserID ${newUserID}`);\n\n            return Promise.resolve(newUserID);\n        }, this[s_userIDCacheTime]);\n    }\n\n    /**\n     * Get (or fetch new) park data\n     */\n    GetParkData() {\n        return this.Cache.Wrap(\"data\", () => {\n            // fetch fresh/updated data\n            return this.FetchParkData(this.DataVersion).then((data) => {\n                var rideData = {};\n                for (var i = 0, item; item = data.Item[i++];) {\n                    rideData[item._id] = item.Name;\n                }\n                return Promise.resolve(rideData);\n            });\n        }, this[s_dataCacheTime]);\n    }\n\n    /**\n     * Get the latest data version timestamp\n     */\n    get DataVersion() {\n        return this[s_dataVersion];\n    }\n\n    /**\n     * Fetch/Sync park data\n     * Warning: full sync is ~30MB\n     */\n    FetchParkData(version) {\n        // this is a recursive function, and will keep fetching data until we get no more deltas to resolve\n        //  note: we should attempt to periodically update the initialVersion to cut down on these requests\n\n        // remember this as the latest version for next fetch\n        this[s_dataVersion] = version;\n\n        // Fetch data\n        return this.MakeAPICall({\n            url: `${this[s_apiBase]}data`,\n            data: {\n                version: version\n            },\n            // we want the full response to get the status code\n            returnFullResponse: true,\n        }).then((response) => {\n            if (response.statusCode === 304 || response.statusCode === 303) {\n                // reject\n                this.Log(`Reached status ${response.statusCode} accessing data version ${version}`);\n                return Promise.reject();\n            } else {\n                this.Log(`Received data for version ${version}`);\n\n                return new Promise((resolve, reject) => {\n                    // unzip data\n                    unzip.fromBuffer(response.body, {\n                        lazyEntries: true\n                    }, (err, zip) => {\n                        var manifestData;\n                        var recordsData;\n\n                        this.Log(\"Parsing zip file\");\n                        if (err) {\n                            return reject(err);\n                        }\n\n                        const GetNextEntry = () => {\n                            if (manifestData && recordsData) {\n                                // got both the files we need, stop reading the zip file\n\n                                // fetch next data URL\n                                if (manifestData.version) {\n                                    this.FetchParkData(manifestData.version).catch(() => {\n                                        // as soon as we hit an error, return the current level or records data\n                                        return resolve(recordsData);\n                                    });\n                                } else {\n                                    return resolve(recordsData);\n                                }\n                            } else {\n                                // read next entry\n                                zip.readEntry();\n                            }\n                        };\n\n                        zip.on(\"entry\", (file) => {\n                            this.Log(`Got zip file ${file.fileName}`);\n\n                            // look for the two files we want\n                            if (file.fileName == \"manifest.json\") {\n                                ReadZipFile(zip, file).then((data) => {\n                                    manifestData = data;\n\n                                    GetNextEntry();\n                                });\n                            } else if (file.fileName == \"records.json\") {\n                                ReadZipFile(zip, file).then((data) => {\n                                    recordsData = data;\n\n                                    GetNextEntry();\n                                });\n                            } else {\n                                GetNextEntry();\n                            }\n                        });\n\n                        // start reading file...\n                        zip.readEntry();\n                    });\n                });\n            }\n        }).catch(err => {\n            if (this[s_fallbackData]) {\n                return this[s_fallbackData];\n            }\n            throw err;\n        });\n    }\n\n    /**\n     * Get default fallback data for this Merlin Park\n     */\n    get FallbackData() {\n        return this[s_fallbackData];\n    }\n\n    /**\n     * Generic API request function, will sort out API token and send auth headers\n     * @param {*} options \n     * @param {String} options.url URL to access\n     * @param {String} [options.method=GET] method to use\n     * @param {Object} [options.data={}] data/query string to use\n     */\n    MakeAPICall(options = {\n        method: \"GET\",\n        data: {}\n    }) {\n        // get token\n        return this.RegisterDevice().then((token) => {\n            // inject auth headers into request headers\n            if (!options.headers) {\n                options.headers = {};\n            }\n            options.headers[\"occasio-platform\"] = \"Android\";\n            options.headers[\"occasio-platform-version\"] = \"6.0.1\";\n            options.headers[\"occasio-app-version\"] = this[s_appVersion];\n            options.headers[\"occasio-app-build\"] = this[s_appBuild];\n            options.headers[\"authorization\"] = `Attractions-Io api-key \"${this[s_apiKey]}\", installation-token=\"${token}\"`;\n\n            // make API call\n            return this.HTTP(options);\n        });\n    }\n\n    applyDateRange(startDate, endDate, isOpen, openingHours) {\n        if (!startDate || !endDate) {\n            this.Log(`Unable to process the range ${startDate} to ${endDate}`);\n            return;\n        }\n\n        let validRange = true;\n        var range = {\n            startDate: Moment(startDate, \"YYYY-MM-DDTHH:mm:ss\").startOf(\"day\"),\n            endDate: Moment(endDate, \"YYYY-MM-DDTHH:mm:ss\").endOf(\"day\"),\n            type: isOpen ? \"Operating\" : \"Closed\"\n        };\n\n        this.Log(`Processing ${range.startDate} => ${range.endDate}`);\n\n        if (isOpen) {\n            let result;\n            // figure out opening times for this range\n            if (result = /([0-9:]+\\s?[ap]m)\\s*-\\s*([0-9:]+\\s?[ap]m)/gi.exec(openingHours.replace(/\\./g, \":\"))) {\n                range.openingTime = Moment(result[1].replace(/ /g, \"\"), \"HH:mma\");\n                range.closingTime = Moment(result[2].replace(/ /g, \"\"), \"HH:mma\");\n            }\n            // try shorthand format too, in case someone entered the times in badly\n            else if (result = /([0-9]+)\\s*-\\s*([0-9]+)/gi.exec(openingHours.replace(/\\./g, \":\"))) {\n                range.openingTime = Moment(result[1] + \":00am\", \"HH:mma\");\n                range.closingTime = Moment(result[2] + \":00pm\", \"HH:mma\");\n            } else {\n                validRange = false;\n                this.Log(`Unable to understand hour format: ${openingHours}`);\n            }\n        }\n\n        if (validRange) {\n            this.Schedule.SetRange(range);\n        }\n    }\n}\n\n// export the class\nmodule.exports = MerlinPark;\n\n// static functions\nfunction ReadZipFile(zip, file) {\n    return new Promise((resolve, reject) => {\n        var data = \"\";\n        zip.openReadStream(file, function(err, readStream) {\n            if (err) {\n                return reject(err);\n            }\n\n            readStream.on(\"data\", function(chunk) {\n                data += chunk;\n            }).on(\"end\", function() {\n                // parse JSON data\n                try {\n                    data = JSON.parse(data);\n                    return resolve(data);\n                } catch (e) {\n                    return reject(`JSON parse error extracting ${file.fileName}: ${e}`);\n                }\n            });\n        });\n    });\n}"]}