{"version":3,"sources":["../lib/http.js"],"names":["needle","require","Log","Promise","MakeRequest","networkRequest","arguments","length","reject","url","requestMethod","method","requestURL","requestData","data","body","undefined","retries","retryDelay","returnFullResponse","forceJSON","resolve","attempt","attemptRequest","request","err","resp","statusCode","JSON","stringify","setTimeout","headers","indexOf","constructor","JSONData","parse","e","process","nextTick","bind","module","exports"],"mappings":"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","file":"http.js","sourcesContent":["\"use strict\";\n\n// this is a basic wrapper for making Request() requests\n//  we wrap this so we can have the same debug information for all requests\n\nvar needle = require(\"needle\");\n\n// get our project Log function for writing log output\nvar Log = require(\"./debugPrint\");\n\n// include our Promise library\nvar Promise = require(\"./promise\");\n\n/**\n * Make a network request\n * @private\n * @param parameters to pass to request library\n */\nfunction MakeRequest(networkRequest) {\n    if (arguments.length != 1) {\n        return Promise.reject(\"HTTP requires 1 argument. The network object configuration\");\n    }\n\n    // debug log if we're in debug mode\n    Log(`Making request to ${networkRequest.url}`);\n\n    // grab method from the request (we'll call .[method] directly using the needle library)\n    var requestMethod = networkRequest.method || \"get\";\n    delete networkRequest.method;\n\n    // extract the required URL\n    var requestURL = networkRequest.url;\n    if (!requestURL) return Promise.reject(`No URL defined for ${requestMethod} request`);\n    delete networkRequest.url;\n\n    var requestData = networkRequest.data || networkRequest.body || undefined;\n    delete networkRequest.data;\n    delete networkRequest.body;\n\n    // build-in retires into this wrapper (default 3)\n    var retries = networkRequest.retries || 3;\n    // un-set retries in-case request suddenly supports this or something!\n    delete networkRequest.retries;\n\n    // default delay of 2 seconds for each retry attempt\n    var retryDelay = networkRequest.retryDelay || 2000;\n    delete networkRequest.retryDelay;\n\n    // we will default to returning the body, but can return the full response object if we want\n    var returnFullResponse = networkRequest.returnFullResponse || false;\n    delete networkRequest.returnFullResponse;\n\n    // add ability to force responses into JSON objects, even if they don't return application/json content header\n    var forceJSON = networkRequest.forceJSON || false;\n    delete networkRequest.forceJSON;\n\n    // return result as a Promise!\n    return new Promise(function (resolve, reject) {\n        var attempt = 0;\n\n        // make request in an anonymouse function so we can make multiple requests to it easily\n        var attemptRequest = function () {\n            Log(`Calling ${requestMethod}:${requestURL}`);\n\n            // build Needle request\n            needle.request(requestMethod, requestURL, requestData, networkRequest, function (err, resp) {\n                if (err || resp.statusCode >= 400 || (resp.statusCode == 200 && !resp.body)) {\n                    Log(`Network request failed attempt ${attempt}/${retries} for URL ${requestURL}`);\n                    Log(err || (resp.statusCode + \": \" + JSON.stringify(resp.body, null, 2)));\n\n                    // if we have retires left, try again!\n                    attempt++;\n                    if (attempt < retries) {\n                        // try again after retryDelay milliseconds\n                        setTimeout(attemptRequest, retryDelay);\n                        return;\n                    } else {\n                        return reject(err || (resp.statusCode + \": \" + JSON.stringify(resp.body, null, 2)));\n                    }\n                }\n\n                // no error! return the result\n                if (returnFullResponse) {\n                    Log(`Successfully fetched response for URL ${requestURL}`);\n                    return resolve(resp);\n                } else {\n                    // enable \"forceJSON\" if the return header type is \"application/json\"\n                    if (resp.headers && resp.headers[\"content-type\"] && resp.headers[\"content-type\"].indexOf(\"application/json\") >= 0) {\n                        Log(\"Found 'application/json' header from in HTTP request, parsing JSON data\");\n                        forceJSON = true;\n                    }\n\n                    // if we want to force JSON (and we're not already a JSON object!)\n                    if (forceJSON && resp.body.constructor !== {}.constructor && resp.body.constructor !== [].constructor) {\n                        let JSONData = null;\n                        try {\n                            JSONData = JSON.parse(resp.body);\n                        } catch (e) {\n                            Log(`Error pasing JSON data: ${e}`);\n                            JSONData = null;\n                        }\n\n                        if (JSONData === null) {\n                            // if we have retires left, try again!\n                            attempt++;\n                            if (attempt < retries) {\n                                // try again after retryDelay milliseconds\n                                setTimeout(attemptRequest, retryDelay);\n                                return;\n                            } else {\n                                return reject(`Unable to parse ${resp.body} into a JSON object`);\n                            }\n                        }\n\n                        Log(`Successfully fetched and parsed JSON from response at ${requestURL}`);\n                        return resolve(JSONData);\n                    } else {\n                        Log(`Successfully fetched body for URL ${requestURL}`);\n                        return resolve(resp.body);\n                    }\n                }\n            });\n        };\n\n        // make first request attempt\n        process.nextTick(attemptRequest);\n    }.bind(this));\n}\n\nmodule.exports = MakeRequest;"]}