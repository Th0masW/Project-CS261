{"version":3,"sources":["../../lib/efteling/index.js"],"names":["Moment","require","Park","GeoLocation","s_apiVersion","Symbol","s_apiKey","s_searchURL","s_waitTimesURL","Efteling","options","name","timezone","latitude","longitude","useragent","api_version","api_key","search_url","wait_times_url","Cache","Wrap","FetchPOIData","bind","HTTP","url","data","then","result","hits","hit","Error","poiData","map","fields","category","id","latlon","match","exec","location","GetPOIData","FetchWaitTimesData","waitData","AttractionInfo","item","Type","Id","rideObject","GetRideObject","State","WaitTime","parseInt","WaitingTime","Promise","resolve","MakeRequest","language","requestOptions","error","headers","endMonth","tz","Timezone","add","ScheduleDays","datePointer","months","Log","format","isSameOrBefore","push","month","year","all","FetchOpeningTimesByMonth","results","hours","times","Schedule","SetDate","date","open","openingTime","closingTime","close","OpeningHours","i","Date","Open","Close","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const Moment = require(\"moment-timezone\");\n\nconst Park = require(\"../park\");\n\nconst GeoLocation = require(\"../geoLocation.js\");\n\nconst s_apiVersion = Symbol();\nconst s_apiKey = Symbol();\nconst s_searchURL = Symbol();\nconst s_waitTimesURL = Symbol();\n\n/**\n * Implements the Efteling API framework.\n * @class\n * @extends Park\n */\nclass Efteling extends Park {\n    /**\n     * Create new Efteling Object.\n     * @param {Object} [options]\n     * @param {String} [options.api_version] Version of the API to reference in request headers\n     * @param {String} [options.api_key] API Key\n     * @param {String} [options.digest_key] Key used to generate URL header digest\n     * @param {String} [options.crypto_key] Key to decrypt wait times\n     * @param {String} [options.crypto_cipher] Cipher to decrypt wait times\n     * @param {Buffer} [options.crypto_iv] IV to decrypt wait times\n     * @param {String} [options.search_url] URL used for fetching POI data\n     */\n    constructor(options = {}) {\n        options.name = options.name || \"Efteling\";\n\n        options.timezone = options.timezone || \"Europe/Amsterdam\";\n\n        // set park's location as it's entrance\n        options.latitude = options.latitude || 51.64990915659694;\n        options.longitude = options.longitude || 5.043561458587647;\n\n        options.useragent = options.useragent || \"okhttp/3.10.0\";\n\n        // inherit from base class\n        super(options);\n\n        // api settings\n        this[s_apiVersion] = options.api_version || \"5\";\n        this[s_apiKey] = options.api_key || \"RMHA53uMzT3ZQhrqoxujG6aVPPYwozMz5Gsb21I9\";\n\n        // URL settings\n        this[s_searchURL] = options.search_url || \"http://prd-search-acs.efteling.com/2013-01-01/\";\n        this[s_waitTimesURL] = options.wait_times_url || \"https://api.efteling.com/app/wis/\";\n    }\n\n    /**\n     * Get POI data for this park (from the cache or fetch fresh data if none is cached)\n     * @returns {Promise}\n     */\n    GetPOIData() {\n        return this.Cache.Wrap(\"poidata\", this.FetchPOIData.bind(this), 60 * 60 * 24);\n    }\n\n    /**\n     * Fetch POI data for the park.\n     * Don't call this function directly unless you know what you're doing. Use GetPOIData instead to use cached data when possible.\n     * @returns {Promise} Object of Ride IDs => Object containing name and location (GeoLocation object, if location is available for this ride)\n     */\n    FetchPOIData() {\n        return this.HTTP({\n            url: `${this[s_searchURL]}search`,\n            data: {\n                \"size\": 1000,\n                \"q.parser\": \"structured\",\n                \"q\": \"(phrase field=language 'en')\"\n            }\n        }).then((result) => {\n            if (!result || !result.hits || !result.hits.hit) {\n                throw new Error(`No results returned for POI data for Efteling Park: ${result}`);\n            }\n\n            var poiData = {};\n\n            result.hits.hit.map((hit) => {\n                if (hit.fields) {\n                    // ignore non-attractions\n                    if (hit.fields.category == \"attraction\") {\n                        poiData[hit.fields.id] = {\n                            name: hit.fields.name,\n                        };\n\n                        // try to parse lat/long\n                        //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\n                        if (hit.fields.latlon && hit.fields.latlon != \"0.0,0.0\") {\n                            var match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\n                            if (match) {\n                                poiData[hit.fields.id].location = new GeoLocation({\n                                    latitude: match[1],\n                                    longitude: match[2]\n                                });\n                            }\n                        }\n                    }\n                }\n            });\n\n            return poiData;\n        });\n    }\n\n    /**\n     * Fetch park wait times\n     * @returns {Promise}\n     */\n    FetchWaitTimes() {\n        // first, get POI data\n        return this.GetPOIData().then((poiData) => {\n            // then, get latest wait time results\n            return this.FetchWaitTimesData().then((waitData) => {\n                // parse and inject into park data\n                if (!waitData.AttractionInfo) throw new Error(\"No AttractionInfo found for Efteling Park response\");\n\n                waitData.AttractionInfo.map((item) => {\n                    // check we have POI data and item is an attraction\n                    if (item.Type == \"Attraction\" && poiData[item.Id]) {\n                        var rideObject = this.GetRideObject({\n                            id: item.Id,\n                            name: poiData[item.Id].name\n                        });\n\n                        if (rideObject) {\n                            // update ride with wait time data\n                            if(item.State == \"storing\"){\n                                //Ride down because of an interruption\n                                rideObject.WaitTime = -2;\n                            }else if(item.State == \"inonderhoud\"){\n                                //Ride down because of maintenance/refurbishment\n                                rideObject.WaitTime = -3; \n                            }else if(item.State == \"open\"){\n                                //Ride operating\n                                rideObject.WaitTime = parseInt(item.WaitingTime, 10);\n                            }else{\n                                //Ride closed\n                                rideObject.WaitTime = -1;\n                            }\n                        }\n                    }\n                });\n\n                return Promise.resolve();\n            });\n        });\n    }\n\n    /**\n     * Fetch the raw wait times data for Efteling Park\n     */\n    FetchWaitTimesData() {\n        return this.MakeRequest({\n            url: this[s_waitTimesURL],\n            data: {\n                language: \"en\"\n            }\n        });\n    }\n\n    /**\n     * Make an API request against the Efteling API\n     * Injects required headers and passes request through to standard HTTP method\n     * See HTTP for full documentation on how to use\n     * @param {Object} requestOptions \n     * @return {Promise}\n     */\n    MakeRequest(requestOptions) {\n        if (!requestOptions.url) {\n            return Promise.error(\"No URL supplied\");\n        }\n\n        // add our required headers\n        if (!requestOptions.headers) requestOptions.headers = {};\n        requestOptions.headers[\"x-api-version\"] = this[s_apiVersion];\n        requestOptions.headers[\"x-api-key\"] = this[s_apiKey];\n\n        return this.HTTP(requestOptions);\n    }\n\n    /**\n     * Request park opening times.\n     * @returns {Promise}\n     */\n    FetchOpeningTimes() {\n        // calculate how many (and which) months we want to check\n        const endMonth = Moment().tz(this.Timezone).add(this.ScheduleDays, \"days\");\n        var datePointer = Moment().tz(this.Timezone);\n        const months = [];\n\n        this.Log(`Fetching opening hours between ${datePointer.format()} and ${endMonth.format()}`);\n\n        // slide along between start and end until we go past endMonth to get an array of required month/year combos\n        while (datePointer.isSameOrBefore(endMonth, \"month\")) {\n            months.push({\n                month: datePointer.format(\"M\"),\n                year: datePointer.format(\"YYYY\")\n            });\n            datePointer.add(1, \"months\");\n        }\n\n        // loop through each month, calling FetchOpeningTimesByMonth\n        return Promise.all(months.map((month) => {\n            return this.FetchOpeningTimesByMonth(month.month, month.year);\n        })).then((results) => {\n            // inject results into calendar\n            results.map((hours) => {\n                hours.map((times) => {\n                    this.Schedule.SetDate({\n                        date: times.open,\n                        openingTime: times.open,\n                        closingTime: times.close\n                    });\n                });\n            });\n            return results;\n        });\n    }\n\n    /**\n     * Fetch park opening times for a specific month and add to park's opening times\n     * @param {String} month\n     * @param {String} [year]\n     * @returns {Promise} Array of Objects containing \"open\" and \"close\" Moment objects\n     */\n    FetchOpeningTimesByMonth(month, year) {\n        // default to current year if none supplied\n        if (!year) {\n            year = Moment.tz(this.Timezone).format(\"YYYY\");\n        }\n\n        return this.HTTP({\n            url: `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\n            headers: {\n                \"X-Requested-With\": \"XMLHttpRequest\"\n            }\n        }).then((data) => {\n            if (!data) throw new Error(`Invalid data returned for park opening hours for ${month}/${year}`);\n            if (!data.OpeningHours) throw new Error(`No park opening hours data returned for ${month}/${year}`);\n\n            // build array of Moment objects for each open and close time\n            const result = [];\n            for (var i = 0, date; date = data.OpeningHours[i++];) {\n                const open = Moment.tz(`${date.Date}${date.Open}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\n                const close = Moment.tz(`${date.Date}${date.Close}`, \"YYYY-MM-DDHH:mm\", this.Timezone);\n                result.push({\n                    open,\n                    close,\n                });\n            }\n            return result;\n        });\n    }\n}\n\nmodule.exports = Efteling;\n"]}